# 实战演练二：单片机Modbus从机开发

本章将详细介绍如何使用单片机开发基于RS485的Modbus从机设备，包括硬件连接、代码实现和调试方法。我们将以STM32单片机为例，开发一个具有温度和湿度功能的Modbus从机设备。

## 硬件准备

<details>
<summary>实验所需硬件清单</summary>

- STM32F103系列单片机开发板
- MAX485芯片模块
- 温湿度传感器（如DHT11/DHT22）
- USB转TTL/RS485调试模块
- 杜邦线若干
- 电源模块（5V）
- 面包板（用于硬件连接）

</details>

## 硬件连接

将RS485模块与STM32单片机的UART接口相连：

<div style="background-color: #e9f7fe; padding: 15px; margin: 15px 0; border-left: 4px solid #4cb3d4; border-radius: 3px;">
<strong>STM32与MAX485连接方式：</strong><br>
- STM32 UART_TX → MAX485 DI (数据输入)<br>
- STM32 UART_RX → MAX485 RO (数据输出)<br>
- STM32 GPIO_Pin → MAX485 DE & RE (方向控制)<br>
- 5V电源 → MAX485 VCC<br>
- GND → MAX485 GND<br>
- MAX485 A、B线连接到RS485总线
</div>

<div style="text-align: center; margin: 15px 0;">
[此处需插入硬件连接实物图和原理图]
</div>

### 方向控制管脚设置

MAX485作为半双工设备，需要通过DE/RE引脚控制数据收发方向，我们将它们连接到一个GPIO引脚上（此例中使用PA1）：

| 模式 | DE/RE状态 | 功能 |
|------|-----------|------|
| 接收模式 | 低电平 | MAX485可以接收来自总线的数据 |
| 发送模式 | 高电平 | MAX485将单片机数据发送到总线 |

## 软件设计

### 初始化配置

1. 初始化STM32 UART外设（常用参数：9600波特率，8数据位，1停止位，无校验）
2. 初始化方向控制GPIO（PA1）
3. 初始化定时器（用于超时接收检测）
4. 初始化温湿度传感器（根据具体型号而定）

### 关键数据结构定义

```c
// Modbus从机参数结构体
typedef struct {
    uint8_t slaveAddress;         // 从机地址（默认为1）
    uint8_t rxBuffer[256];        // 接收缓冲区
    uint16_t rxCount;             // 接收计数
    uint8_t txBuffer[256];        // 发送缓冲区
    uint16_t registerMap[32];     // 寄存器映射表
    uint32_t lastReceiveTime;     // 最后接收时间（用于超时检测）
    uint8_t timeout;              // 超时标志
} ModbusSlave;

// 初始化Modbus从机
ModbusSlave modbus = {
    .slaveAddress = 1,            // 默认地址
    .rxCount = 0,
    .timeout = 0
};
```

### 寄存器映射定义

为了在单片机程序中方便管理数据，我们需要定义寄存器地址映射：

```c
// 寄存器地址定义
#define REG_TEMPERATURE       0x0000  // 温度寄存器（只读）
#define REG_HUMIDITY          0x0001  // 湿度寄存器（只读）
#define REG_DEV_ADDRESS       0x0066  // 设备地址（读/写）
#define REG_BAUD_RATE         0x0067  // 波特率配置（读/写）
#define REG_VERIFY_MODE       0x0068  // 校验方式（读/写）
```

### 串口接收中断处理

在单片机实现Modbus通信中，串口接收中断处理十分关键：

<details>
<summary>UART接收中断处理代码</summary>

```c
void USART1_IRQHandler(void)
{
    uint8_t receivedByte;
    
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        // 清除中断标志
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
        
        // 读取接收到的数据
        receivedByte = USART_ReceiveData(USART1);
        
        // 重启字符间超时计时器
        TIM_SetCounter(TIM2, 0);
        TIM_Cmd(TIM2, ENABLE);
        
        // 存入接收缓冲区
        if(modbus.rxCount < sizeof(modbus.rxBuffer))
        {
            modbus.rxBuffer[modbus.rxCount++] = receivedByte;
        }
        
        // 记录接收时间（用于帧超时检测）
        modbus.lastReceiveTime = HAL_GetTick();
    }
}
```

</details>

### 超时检测实现

Modbus RTU模式需要依靠超时来判断一帧数据的结束，我们通过定时器实现这一功能：

```c
// 定时器配置（假设系统时钟为72MHz）
void TIM2_Config(void)
{
    // 配置定时器，使其产生大约3.5个字符时间的超时
    // 9600波特率时，1个字符约1.042ms，3.5个字符约3.65ms
    
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    
    TIM_TimeBaseStructure.TIM_Period = 365; // 3.65ms超时
    TIM_TimeBaseStructure.TIM_Prescaler = 720-1; // 72MHz/720=100KHz
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
    
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    
    // 默认禁用，只在接收到第一个字节时启动
    TIM_Cmd(TIM2, DISABLE);
}

// 定时器中断处理函数
void TIM2_IRQHandler(void)
{
    if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
        TIM_Cmd(TIM2, DISABLE); // 停止定时器
        
        // 标记帧接收完成
        modbus.timeout = 1;
    }
}
```

### RS485方向控制函数

对于半双工的RS485通信，需要通过GPIO控制数据的收发方向：

```c
// 设置RS485方向（发送或接收）
void RS485_SetDirection(uint8_t direction)
{
    if(direction == 1) // 发送模式
    {
        GPIO_SetBits(GPIOA, GPIO_Pin_1);   // DE/RE = 1
    }
    else // 接收模式
    {
        GPIO_ResetBits(GPIOA, GPIO_Pin_1); // DE/RE = 0
    }
}
```

### CRC校验计算函数

Modbus RTU模式需要使用CRC16校验：

<details>
<summary>CRC16校验代码</summary>

```c
// 计算CRC16校验值
uint16_t ModbusCRC16(uint8_t *buffer, uint16_t length)
{
    uint16_t crc = 0xFFFF;
    uint16_t pos;
    uint8_t i;
    
    for(pos = 0; pos < length; pos++)
    {
        crc ^= (uint16_t)buffer[pos];
        
        for(i = 8; i != 0; i--)
        {
            if((crc & 0x0001) != 0)
            {
                crc >>= 1;
                crc ^= 0xA001;
            }
            else
            {
                crc >>= 1;
            }
        }
    }
    
    return crc;
}
```

</details>

### Modbus功能码处理

根据Modbus协议，主要实现以下功能码处理：

<details>
<summary>功能码03（读保持寄存器）处理</summary>

```c
// 处理功能码03（读保持寄存器）
void ModbusProcessFC03(void)
{
    uint16_t startAddr, regCount;
    uint16_t i, byte_cnt;
    uint16_t crc;
    
    // 提取起始地址和寄存器数量
    startAddr = (modbus.rxBuffer[2] << 8) | modbus.rxBuffer[3];
    regCount = (modbus.rxBuffer[4] << 8) | modbus.rxBuffer[5];
    
    // 检查地址和数量是否有效
    if((startAddr + regCount <= 32) && (regCount > 0) && (regCount <= 125))
    {
        // 准备响应数据
        byte_cnt = regCount * 2;
        
        modbus.txBuffer[0] = modbus.slaveAddress;
        modbus.txBuffer[1] = 0x03;
        modbus.txBuffer[2] = byte_cnt;
        
        // 填充寄存器数据
        for(i = 0; i < regCount; i++)
        {
            modbus.txBuffer[3 + i*2] = (modbus.registerMap[startAddr + i] >> 8) & 0xFF;
            modbus.txBuffer[4 + i*2] = modbus.registerMap[startAddr + i] & 0xFF;
        }
        
        // 计算CRC校验
        crc = ModbusCRC16(modbus.txBuffer, byte_cnt + 3);
        modbus.txBuffer[byte_cnt + 3] = crc & 0xFF;
        modbus.txBuffer[byte_cnt + 4] = (crc >> 8) & 0xFF;
        
        // 发送响应
        RS485_SetDirection(1); // 设置为发送模式
        
        for(i = 0; i < byte_cnt + 5; i++)
        {
            USART_SendData(USART1, modbus.txBuffer[i]);
            while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
        }
        
        RS485_SetDirection(0); // 恢复接收模式
    }
    else
    {
        // 发送异常响应（非法数据地址或数量）
        ModbusSendException(0x03, 0x02);
    }
}
```

</details>

<details>
<summary>功能码06（写单个寄存器）处理</summary>

```c
// 处理功能码06（写单个寄存器）
void ModbusProcessFC06(void)
{
    uint16_t regAddr, regValue;
    uint16_t i;
    uint16_t crc;
    
    // 提取寄存器地址和值
    regAddr = (modbus.rxBuffer[2] << 8) | modbus.rxBuffer[3];
    regValue = (modbus.rxBuffer[4] << 8) | modbus.rxBuffer[5];
    
    // 检查地址是否有效
    if(regAddr < 32)
    {
        // 更新寄存器值
        modbus.registerMap[regAddr] = regValue;
        
        // 特殊处理特定寄存器
        if(regAddr == REG_DEV_ADDRESS)
        {
            // 更新设备地址
            if(regValue >= 1 && regValue <= 247)
            {
                modbus.slaveAddress = regValue;
                // 可以将新地址保存到EEPROM或Flash中
            }
        }
        else if(regAddr == REG_BAUD_RATE)
        {
            // 处理波特率设置
            // 实际应用中需重新配置UART
        }
        
        // 准备响应（与请求帧相同）
        for(i = 0; i < 6; i++)
        {
            modbus.txBuffer[i] = modbus.rxBuffer[i];
        }
        
        // 计算CRC校验
        crc = ModbusCRC16(modbus.txBuffer, 6);
        modbus.txBuffer[6] = crc & 0xFF;
        modbus.txBuffer[7] = (crc >> 8) & 0xFF;
        
        // 发送响应
        RS485_SetDirection(1); // 设置为发送模式
        
        for(i = 0; i < 8; i++)
        {
            USART_SendData(USART1, modbus.txBuffer[i]);
            while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
        }
        
        RS485_SetDirection(0); // 恢复接收模式
    }
    else
    {
        // 发送异常响应（非法数据地址）
        ModbusSendException(0x06, 0x02);
    }
}
```

</details>

<details>
<summary>功能码16（写多个寄存器）处理</summary>

```c
// 处理功能码16（写多个寄存器）
void ModbusProcessFC16(void)
{
    uint16_t startAddr, regCount, byteCount;
    uint16_t i;
    uint16_t crc;
    
    // 提取起始地址、寄存器数量和字节数
    startAddr = (modbus.rxBuffer[2] << 8) | modbus.rxBuffer[3];
    regCount = (modbus.rxBuffer[4] << 8) | modbus.rxBuffer[5];
    byteCount = modbus.rxBuffer[6];
    
    // 检查地址和数量是否有效
    if((startAddr + regCount <= 32) && (regCount > 0) && (regCount <= 123) && (byteCount == regCount * 2))
    {
        // 更新寄存器值
        for(i = 0; i < regCount; i++)
        {
            modbus.registerMap[startAddr + i] = (modbus.rxBuffer[7 + i*2] << 8) | modbus.rxBuffer[8 + i*2];
        }
        
        // 处理特殊寄存器（如设备地址、波特率等）
        for(i = 0; i < regCount; i++)
        {
            if(startAddr + i == REG_DEV_ADDRESS)
            {
                if(modbus.registerMap[REG_DEV_ADDRESS] >= 1 && modbus.registerMap[REG_DEV_ADDRESS] <= 247)
                {
                    modbus.slaveAddress = modbus.registerMap[REG_DEV_ADDRESS];
                    // 可以将新地址保存到EEPROM或Flash中
                }
            }
            // 处理其他特殊寄存器...
        }
        
        // 准备响应
        modbus.txBuffer[0] = modbus.slaveAddress;
        modbus.txBuffer[1] = 0x10;  // 功能码
        modbus.txBuffer[2] = (startAddr >> 8) & 0xFF;
        modbus.txBuffer[3] = startAddr & 0xFF;
        modbus.txBuffer[4] = (regCount >> 8) & 0xFF;
        modbus.txBuffer[5] = regCount & 0xFF;
        
        // 计算CRC校验
        crc = ModbusCRC16(modbus.txBuffer, 6);
        modbus.txBuffer[6] = crc & 0xFF;
        modbus.txBuffer[7] = (crc >> 8) & 0xFF;
        
        // 发送响应
        RS485_SetDirection(1); // 设置为发送模式
        
        for(i = 0; i < 8; i++)
        {
            USART_SendData(USART1, modbus.txBuffer[i]);
            while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
        }
        
        RS485_SetDirection(0); // 恢复接收模式
    }
    else
    {
        // 发送异常响应（非法数据地址或数量）
        ModbusSendException(0x10, 0x02);
    }
}
```

</details>

### 异常响应处理

当收到错误的请求时，需要返回异常响应：

```c
// 发送Modbus异常响应
void ModbusSendException(uint8_t functionCode, uint8_t exceptionCode)
{
    uint16_t crc;
    uint8_t i;
    
    modbus.txBuffer[0] = modbus.slaveAddress;
    modbus.txBuffer[1] = functionCode | 0x80;  // 功能码最高位置1表示异常
    modbus.txBuffer[2] = exceptionCode;
    
    // 计算CRC校验
    crc = ModbusCRC16(modbus.txBuffer, 3);
    modbus.txBuffer[3] = crc & 0xFF;
    modbus.txBuffer[4] = (crc >> 8) & 0xFF;
    
    // 发送异常响应
    RS485_SetDirection(1); // 设置为发送模式
    
    for(i = 0; i < 5; i++)
    {
        USART_SendData(USART1, modbus.txBuffer[i]);
        while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
    }
    
    RS485_SetDirection(0); // 恢复接收模式
}
```

### 主循环处理接收数据

在主循环中处理接收到的Modbus数据帧：

```c
void ModbusProcessData(void)
{
    uint16_t crc, recvCRC;
    
    // 检查是否接收到完整帧（由超时触发）
    if(modbus.timeout && modbus.rxCount >= 8) // 最小帧长为8字节
    {
        modbus.timeout = 0;
        
        // 计算CRC校验
        crc = ModbusCRC16(modbus.rxBuffer, modbus.rxCount - 2);
        recvCRC = (modbus.rxBuffer[modbus.rxCount - 1] << 8) | modbus.rxBuffer[modbus.rxCount - 2];
        
        // 如果CRC校验通过且地址匹配
        if((crc == recvCRC) && (modbus.rxBuffer[0] == modbus.slaveAddress || modbus.rxBuffer[0] == 0))
        {
            // 根据功能码处理
            switch(modbus.rxBuffer[1])
            {
                case 0x03:  // 读保持寄存器
                    ModbusProcessFC03();
                    break;
                    
                case 0x06:  // 写单个寄存器
                    ModbusProcessFC06();
                    break;
                    
                case 0x10:  // 写多个寄存器
                    ModbusProcessFC16();
                    break;
                    
                default:    // 不支持的功能码
                    ModbusSendException(modbus.rxBuffer[1], 0x01);
                    break;
            }
        }
        
        // 清空接收缓冲区，准备接收新数据
        modbus.rxCount = 0;
    }
}
```

### 传感器数据更新

定期读取传感器数据并更新到寄存器映射表中：

```c
// 更新传感器数据到寄存器
void UpdateSensorData(void)
{
    float temp, humid;
    
    // 读取温湿度传感器（此处以DHT11为例）
    if(DHT11_Read(&temp, &humid) == 0)
    {
        // 转换为Modbus寄存器格式（扩大100倍存储）
        modbus.registerMap[REG_TEMPERATURE] = (uint16_t)(temp * 100);
        modbus.registerMap[REG_HUMIDITY] = (uint16_t)(humid * 100);
    }
}
```

### 主函数

完整的主函数实现：

```c
int main(void)
{
    uint32_t lastUpdateTime = 0;
    
    // 系统初始化
    SystemInit();
    
    // 外设初始化
    UART_Config();         // UART配置
    TIM2_Config();         // 超时定时器配置
    GPIO_Config();         // GPIO配置
    
    // 初始化RS485方向控制为接收模式
    RS485_SetDirection(0);
    
    // 初始化寄存器默认值
    modbus.registerMap[REG_DEV_ADDRESS] = modbus.slaveAddress;
    modbus.registerMap[REG_BAUD_RATE] = 2;  // 默认9600
    modbus.registerMap[REG_VERIFY_MODE] = 0; // 默认无校验
    
    while(1)
    {
        // 处理接收到的Modbus数据
        ModbusProcessData();
        
        // 每500ms更新一次传感器数据
        if(HAL_GetTick() - lastUpdateTime >= 500)
        {
            lastUpdateTime = HAL_GetTick();
            UpdateSensorData();
        }
    }
}
```

## 完整项目编译与调试

### 目录结构

一个完整的项目目录结构如下：

```
project/
├── Core/
│   ├── Inc/
│   │   ├── main.h
│   │   ├── modbus.h
│   │   └── dht11.h
│   └── Src/
│       ├── main.c
│       ├── modbus.c
│       └── dht11.c
├── Drivers/
│   └── ... (STM32 HAL驱动)
└── MDK-ARM/
    └── ... (Keil工程文件)
```

### 调试与测试

完成代码编写后，进行以下测试：

1. **基本通信测试**：使用上位机软件（如Modbus Poll）尝试读取寄存器
2. **CRC校验测试**：修改数据帧观察从机对错误CRC的响应
3. **参数设置测试**：修改地址和波特率，验证修改是否生效
4. **稳定性测试**：长时间运行观察系统的稳定性

<div style="background-color: #e8f5e9; padding: 10px; margin: 15px 0; border-left: 4px solid #4caf50; border-radius: 3px;">
<strong>调试提示：</strong> 在开发过程中，可以通过串口打印调试信息，或使用示波器观察RS485通信波形，这有助于排查通信故障。
</div>

## 常见问题与解决方案

<details>
<summary>无法接收主机请求</summary>

可能的原因：
1. RS485方向控制未正确设置为接收模式
2. 波特率设置错误
3. 接线问题（A/B线接反）
4. 从机地址设置错误

解决方法：
1. 检查RS485_SetDirection(0)函数是否正确执行
2. 验证波特率配置是否与主机一致
3. 确认A/B线连接正确
4. 验证设备地址设置
</details>

<details>
<summary>CRC校验错误</summary>

可能的原因：
1. CRC计算算法实现错误
2. 接收数据不完整
3. 数据传输过程中发生干扰

解决方法：
1. 仔细核对CRC16算法实现
2. 调整超时时间确保完整接收
3. 检查硬件连接和电源质量
</details>

<details>
<summary>通信不稳定</summary>

可能的原因：
1. 代码中的延时处理不当
2. 中断优先级设置不合理
3. RS485方向切换时机不当
4. 缓冲区溢出

解决方法：
1. 优化代码，避免长时间阻塞
2. 调整中断优先级，确保串口接收优先处理
3. 确保在发送完成后才切换方向
4. 增加缓冲区大小或优化数据处理速度
</details>

## 代码优化建议

为了提高系统的稳定性和性能，可以考虑以下优化：

1. **使用DMA**：利用DMA进行UART数据收发，减少CPU负担
2. **参数持久化**：将重要参数（如设备地址、波特率）保存到EEPROM或Flash中
3. **看门狗**：添加看门狗定时器，防止系统异常时卡死
4. **断点续传**：支持断点续传，在通信异常时能够恢复状态
5. **多缓冲区**：使用双缓冲或环形缓冲区处理数据，提高并发性能

## 项目扩展方向

基于本章实现的基础Modbus从机，可以进一步扩展功能：

1. **支持更多功能码**：增加功能码01/02/04/05/15等支持
2. **多UART复用**：支持多个串口同时作为Modbus从机
3. **Modbus主机**：实现Modbus主机功能，主动查询其他设备
4. **Modbus网关**：实现Modbus到其他协议的转换（如Modbus TCP）
5. **远程固件升级**：通过Modbus协议实现远程固件升级功能

---

**需要插入图片的位置**：
1. STM32与MAX485连接实物图
2. 硬件原理图
3. 示波器通信波形图
4. 上位机调试界面图
5. 调试过程关键步骤图

---

## 总结

本章详细介绍了基于STM32单片机开发Modbus从机设备的完整过程，包括硬件连接、软件设计、功能码实现和调试方法。通过本章的学习，读者应该能够掌握：

- RS485与STM32的硬件连接方法
- Modbus从机协议的软件实现
- 超时接收机制的正确实现
- RS485方向控制的关键点
- CRC校验算法的实现
- 常见功能码（03/06/16）的处理流程

这些知识为开发工业控制、智能家居、物联网等领域的通信设备奠定了基础。 