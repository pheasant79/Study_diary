# 代码优化与封装

本章将介绍如何优化和封装Modbus协议相关代码，提高代码的可复用性、可维护性和可靠性，使其更适合在实际产品开发中应用。

## 模块化设计

<details>
<summary>模块化结构设计</summary>

良好的模块化设计可以提高代码的可维护性和可复用性。我们将Modbus协议实现分为以下几个模块：

1. **硬件抽象层**：负责硬件相关操作，如UART、定时器、GPIO等
2. **Modbus核心层**：实现Modbus协议的核心功能
3. **功能码处理层**：处理各类功能码
4. **数据映射层**：管理寄存器与实际数据的映射关系
5. **应用层**：实现具体业务逻辑

```
└── Modbus
    ├── Hardware Abstraction Layer
    │   ├── UART Interface
    │   ├── Timer Interface
    │   └── GPIO Interface
    ├── Modbus Core
    │   ├── Frame Detection
    │   ├── CRC Calculation
    │   └── Exception Handling
    ├── Function Code Handlers
    │   ├── Read Functions
    │   └── Write Functions
    ├── Register Mapping
    │   ├── Register Definition
    │   └── Data Conversion
    └── Application
        └── Business Logic
```
</details>

## 硬件抽象层

<details>
<summary>硬件接口封装</summary>

将硬件操作封装为统一的接口，便于在不同平台上移植：

```c
/* 硬件抽象层头文件：mb_hal.h */
#ifndef MB_HAL_H
#define MB_HAL_H

#include <stdint.h>

/* 初始化硬件 */
void MBH_Init(void);

/* UART操作 */
void MBH_UartInit(uint32_t baudRate, uint8_t dataBits, uint8_t stopBits, uint8_t parity);
void MBH_UartSendByte(uint8_t data);
void MBH_UartSendBuffer(uint8_t *buffer, uint16_t length);
uint16_t MBH_UartReceiveBuffer(uint8_t *buffer, uint16_t maxLen);

/* 定时器操作 */
void MBH_TimerInit(uint32_t timeout_us);
void MBH_TimerStart(void);
void MBH_TimerStop(void);
uint8_t MBH_TimerExpired(void);

/* RS485方向控制 */
void MBH_EnableTransmit(void);
void MBH_EnableReceive(void);

/* 系统时间 */
uint32_t MBH_GetTime(void);

#endif /* MB_HAL_H */
```

</details>

## Modbus核心层

<details>
<summary>核心功能封装</summary>

Modbus核心层实现协议的基本功能，与具体功能码无关：

```c
/* Modbus核心层头文件：mb_core.h */
#ifndef MB_CORE_H
#define MB_CORE_H

#include <stdint.h>
#include "mb_hal.h"
#include "mb_config.h"

/* Modbus错误码 */
typedef enum {
    MB_OK = 0,
    MB_ERROR_INVALID_SLAVE,
    MB_ERROR_INVALID_FUNCTION,
    MB_ERROR_INVALID_DATA,
    MB_ERROR_INVALID_CRC,
    MB_ERROR_PROCESSING,
    MB_ERROR_TIMEOUT
} MBErrorCode;

/* Modbus异常码 */
typedef enum {
    MB_EX_NONE = 0x00,
    MB_EX_ILLEGAL_FUNCTION = 0x01,
    MB_EX_ILLEGAL_DATA_ADDRESS = 0x02,
    MB_EX_ILLEGAL_DATA_VALUE = 0x03,
    MB_EX_SLAVE_DEVICE_FAILURE = 0x04
} MBExceptionCode;

/* Modbus状态 */
typedef enum {
    MB_STATE_IDLE,
    MB_STATE_RECEIVING,
    MB_STATE_PROCESSING,
    MB_STATE_TRANSMITTING
} MBState;

/* Modbus实例结构体 */
typedef struct {
    uint8_t slaveAddress;
    uint8_t rxBuffer[MB_PDU_MAX_SIZE];
    uint16_t rxCount;
    uint8_t txBuffer[MB_PDU_MAX_SIZE];
    uint16_t txCount;
    MBState state;
    uint32_t lastReceiveTime;
} MBInstance;

/* 初始化Modbus */
MBErrorCode MB_Init(MBInstance *instance, uint8_t slaveAddress);

/* 处理接收到的数据 */
MBErrorCode MB_HandleRxData(MBInstance *instance, uint8_t data);

/* 处理超时事件 */
MBErrorCode MB_HandleTimeout(MBInstance *instance);

/* 接收并处理完整的Modbus帧 */
MBErrorCode MB_ProcessFrame(MBInstance *instance);

/* 发送Modbus异常响应 */
MBErrorCode MB_SendException(MBInstance *instance, uint8_t functionCode, MBExceptionCode exceptionCode);

/* 计算CRC校验 */
uint16_t MB_CRC16(uint8_t *buffer, uint16_t length);

#endif /* MB_CORE_H */
```

</details>

## 功能码处理层

通过回调函数机制实现功能码处理，使系统更具扩展性：

```c
/* 功能码处理层接口：mb_function.h */
#ifndef MB_FUNCTION_H
#define MB_FUNCTION_H

#include "mb_core.h"

/* 功能码处理函数指针类型 */
typedef MBErrorCode (*MBFunctionHandler)(MBInstance *instance, uint8_t *rxFrame, uint16_t rxLength);

/* 功能码处理表结构体 */
typedef struct {
    uint8_t functionCode;
    MBFunctionHandler handler;
} MBFunctionHandlerTable;

/* 注册功能码处理函数 */
MBErrorCode MB_RegisterFunctionHandler(uint8_t functionCode, MBFunctionHandler handler);

/* 功能码03处理函数(读保持寄存器) */
MBErrorCode MB_HandleReadHoldingRegisters(MBInstance *instance, uint8_t *rxFrame, uint16_t rxLength);

/* 功能码06处理函数(写单个寄存器) */
MBErrorCode MB_HandleWriteSingleRegister(MBInstance *instance, uint8_t *rxFrame, uint16_t rxLength);

/* 功能码16处理函数(写多个寄存器) */
MBErrorCode MB_HandleWriteMultipleRegisters(MBInstance *instance, uint8_t *rxFrame, uint16_t rxLength);

#endif /* MB_FUNCTION_H */
```

## 数据映射层

<details>
<summary>数据映射层设计</summary>

数据映射层用于管理寄存器与实际数据的映射关系：

```c
/* 数据映射层头文件：mb_mapping.h */
#ifndef MB_MAPPING_H
#define MB_MAPPING_H

#include <stdint.h>
#include "mb_core.h"

/* 寄存器类型 */
typedef enum {
    MB_REG_HOLDING,   /* 保持寄存器 */
    MB_REG_INPUT,     /* 输入寄存器 */
    MB_REG_COIL,      /* 线圈 */
    MB_REG_DISCRETE   /* 离散输入 */
} MBRegisterType;

/* 寄存器访问权限 */
typedef enum {
    MB_ACCESS_RO,     /* 只读 */
    MB_ACCESS_WO,     /* 只写 */
    MB_ACCESS_RW      /* 读写 */
} MBAccessMode;

/* 寄存器回调函数类型 */
typedef uint16_t (*MBRegisterReadCallback)(uint16_t regAddr);
typedef MBErrorCode (*MBRegisterWriteCallback)(uint16_t regAddr, uint16_t regValue);

/* 寄存器映射项 */
typedef struct {
    uint16_t address;
    uint16_t count;
    MBAccessMode accessMode;
    uint16_t *dataPtr;
    MBRegisterReadCallback readCallback;
    MBRegisterWriteCallback writeCallback;
} MBRegisterMapping;

/* 寄存器映射表 */
typedef struct {
    MBRegisterMapping *items;
    uint16_t itemCount;
    uint16_t totalRegisters;
} MBRegisterMappingTable;

/* 初始化寄存器映射表 */
MBErrorCode MB_InitRegisterMapping(MBRegisterMappingTable *table, MBRegisterMapping *items, uint16_t itemCount);

/* 读取寄存器值 */
MBErrorCode MB_ReadRegister(MBRegisterMappingTable *table, uint16_t address, uint16_t *value);

/* 写入寄存器值 */
MBErrorCode MB_WriteRegister(MBRegisterMappingTable *table, uint16_t address, uint16_t value);

/* 检查地址范围是否有效 */
MBErrorCode MB_CheckAddressRange(MBRegisterMappingTable *table, uint16_t address, uint16_t count);

#endif /* MB_MAPPING_H */
```

</details>

## 使用回调函数进行寄存器操作

使用回调函数可以灵活处理寄存器读写操作，实现更复杂的业务逻辑：

```c
/* 应用层代码示例 */

/* 温度寄存器回调函数 */
uint16_t ReadTemperatureRegister(uint16_t regAddr)
{
    float temperature;
    
    /* 读取温度传感器 */
    temperature = ReadTemperatureSensor();
    
    /* 转换为Modbus寄存器格式(扩大100倍) */
    return (uint16_t)(temperature * 100);
}

/* 设备地址寄存器回调函数 */
MBErrorCode WriteDeviceAddressRegister(uint16_t regAddr, uint16_t regValue)
{
    /* 验证地址有效性 */
    if(regValue < 1 || regValue > 247)
    {
        return MB_ERROR_INVALID_DATA;
    }
    
    /* 更新设备地址 */
    mbInstance.slaveAddress = regValue;
    
    /* 保存到非易失性存储器 */
    SaveDeviceAddressToEEPROM(regValue);
    
    return MB_OK;
}

/* 注册回调函数 */
void RegisterCallbacks(void)
{
    /* 定义寄存器映射表 */
    static MBRegisterMapping registerMappings[] = {
        {0x0000, 1, MB_ACCESS_RO, NULL, ReadTemperatureRegister, NULL},
        {0x0001, 1, MB_ACCESS_RO, NULL, ReadHumidityRegister, NULL},
        {0x0066, 1, MB_ACCESS_RW, NULL, ReadDeviceAddressRegister, WriteDeviceAddressRegister}
    };
    
    /* 初始化寄存器映射表 */
    MB_InitRegisterMapping(&mappingTable, registerMappings, sizeof(registerMappings)/sizeof(registerMappings[0]));
}
```

## 错误处理与状态管理

<details>
<summary>完善的错误处理机制</summary>

健壮的错误处理对于工业应用至关重要：

```c
/* 错误日志记录函数 */
void MB_LogError(MBErrorCode errorCode, const char *message)
{
    /* 根据实际应用将错误信息记录到日志系统 */
    LogSystem_Write(LOG_LEVEL_ERROR, "Modbus Error[%d]: %s", errorCode, message);
}

/* 带错误处理的功能实现 */
MBErrorCode MB_ProcessFrame(MBInstance *instance)
{
    MBErrorCode errorCode;
    uint16_t crc, recvCRC;
    
    /* 验证帧长度 */
    if(instance->rxCount < MB_PDU_MIN_SIZE)
    {
        MB_LogError(MB_ERROR_INVALID_DATA, "Frame too short");
        return MB_ERROR_INVALID_DATA;
    }
    
    /* 计算CRC校验 */
    crc = MB_CRC16(instance->rxBuffer, instance->rxCount - 2);
    recvCRC = (instance->rxBuffer[instance->rxCount - 1] << 8) | instance->rxBuffer[instance->rxCount - 2];
    
    if(crc != recvCRC)
    {
        MB_LogError(MB_ERROR_INVALID_CRC, "CRC check failed");
        return MB_ERROR_INVALID_CRC;
    }
    
    /* 验证从机地址 */
    if(instance->rxBuffer[0] != instance->slaveAddress && instance->rxBuffer[0] != 0)
    {
        /* 不是发给当前从机的帧，忽略 */
        return MB_ERROR_INVALID_SLAVE;
    }
    
    /* 处理功能码 */
    uint8_t functionCode = instance->rxBuffer[1];
    MBFunctionHandler handler = MB_GetFunctionHandler(functionCode);
    
    if(handler == NULL)
    {
        /* 不支持的功能码 */
        errorCode = MB_SendException(instance, functionCode, MB_EX_ILLEGAL_FUNCTION);
        MB_LogError(MB_ERROR_INVALID_FUNCTION, "Unsupported function code");
        return errorCode;
    }
    
    /* 调用功能码处理函数 */
    return handler(instance, instance->rxBuffer, instance->rxCount);
}
```

</details>

## 参数持久化管理

在工业应用中，设备参数通常需要保存到非易失性存储器中：

```c
/* 参数持久化存储接口 */
typedef struct {
    uint8_t deviceAddress;
    uint8_t baudRateCode;
    uint8_t parityMode;
    /* 其他需要持久化的参数 */
} MBPersistentConfig;

/* 从EEPROM/Flash加载配置 */
MBErrorCode MB_LoadConfig(MBPersistentConfig *config)
{
    /* 从非易失性存储器读取配置 */
    if(EEPROM_Read(CONFIG_STORAGE_ADDRESS, (uint8_t*)config, sizeof(MBPersistentConfig)) != EEPROM_OK)
    {
        /* 读取失败，使用默认配置 */
        config->deviceAddress = 1;
        config->baudRateCode = 2; /* 9600 */
        config->parityMode = 0;   /* 无校验 */
        return MB_ERROR_PROCESSING;
    }
    
    /* 验证参数有效性 */
    if(config->deviceAddress < 1 || config->deviceAddress > 247)
    {
        config->deviceAddress = 1;
    }
    
    if(config->baudRateCode > 5)
    {
        config->baudRateCode = 2; /* 默认9600 */
    }
    
    if(config->parityMode > 2)
    {
        config->parityMode = 0;
    }
    
    return MB_OK;
}

/* 保存配置到EEPROM/Flash */
MBErrorCode MB_SaveConfig(MBPersistentConfig *config)
{
    /* 将配置写入非易失性存储器 */
    if(EEPROM_Write(CONFIG_STORAGE_ADDRESS, (uint8_t*)config, sizeof(MBPersistentConfig)) != EEPROM_OK)
    {
        return MB_ERROR_PROCESSING;
    }
    
    return MB_OK;
}
```

## 异步通信模型

<details>
<summary>基于状态机的异步处理</summary>

在实际应用中，使用基于状态机的异步处理模型可以提高系统的响应性：

```c
/* Modbus主循环处理 */
void MB_Task(void)
{
    static MBState prevState = MB_STATE_IDLE;
    MBErrorCode errorCode;
    
    /* 状态机处理 */
    switch(mbInstance.state)
    {
        case MB_STATE_IDLE:
            /* 空闲状态，等待接收 */
            if(MBH_TimerExpired() && mbInstance.rxCount > 0)
            {
                /* 超时，表示一个帧接收完成 */
                mbInstance.state = MB_STATE_PROCESSING;
            }
            break;
            
        case MB_STATE_RECEIVING:
            /* 正在接收数据，由中断处理 */
            if(MBH_TimerExpired() && mbInstance.rxCount > 0)
            {
                /* 接收超时，开始处理帧 */
                mbInstance.state = MB_STATE_PROCESSING;
            }
            break;
            
        case MB_STATE_PROCESSING:
            /* 处理接收到的帧 */
            errorCode = MB_ProcessFrame(&mbInstance);
            
            if(errorCode == MB_OK)
            {
                /* 处理成功，等待发送或回到空闲状态 */
                if(mbInstance.txCount > 0)
                {
                    mbInstance.state = MB_STATE_TRANSMITTING;
                    MBH_EnableTransmit();
                    MBH_UartSendBuffer(mbInstance.txBuffer, mbInstance.txCount);
                }
                else
                {
                    mbInstance.state = MB_STATE_IDLE;
                }
            }
            else
            {
                /* 处理错误，回到空闲状态 */
                mbInstance.state = MB_STATE_IDLE;
            }
            
            /* 清空接收缓冲区 */
            mbInstance.rxCount = 0;
            break;
            
        case MB_STATE_TRANSMITTING:
            /* 发送完成后回到空闲状态 */
            if(MBH_UartTxComplete())
            {
                MBH_EnableReceive();
                mbInstance.state = MB_STATE_IDLE;
                mbInstance.txCount = 0;
            }
            break;
            
        default:
            /* 异常状态，重置为空闲 */
            mbInstance.state = MB_STATE_IDLE;
            break;
    }
    
    /* 状态变化时记录日志 */
    if(prevState != mbInstance.state)
    {
        prevState = mbInstance.state;
        LogSystem_Write(LOG_LEVEL_DEBUG, "Modbus state changed to %d", mbInstance.state);
    }
}
```

通过状态机模型，系统可以在不阻塞的情况下处理Modbus通信，同时处理其他任务。

</details>

## 线程安全设计

在多线程环境中，需要考虑线程安全问题：

```c
/* 线程安全的Modbus操作 */

/* 互斥锁定义 */
static SemaphoreHandle_t mbMutex;

/* 初始化互斥锁 */
void MB_InitMutex(void)
{
    mbMutex = xSemaphoreCreateMutex();
}

/* 线程安全的寄存器读取 */
MBErrorCode MB_ThreadSafeReadRegister(uint16_t address, uint16_t *value)
{
    MBErrorCode result;
    
    /* 获取互斥锁 */
    if(xSemaphoreTake(mbMutex, portMAX_DELAY) == pdTRUE)
    {
        /* 执行寄存器读取 */
        result = MB_ReadRegister(&mappingTable, address, value);
        
        /* 释放互斥锁 */
        xSemaphoreGive(mbMutex);
        
        return result;
    }
    
    return MB_ERROR_PROCESSING;
}

/* 线程安全的寄存器写入 */
MBErrorCode MB_ThreadSafeWriteRegister(uint16_t address, uint16_t value)
{
    MBErrorCode result;
    
    /* 获取互斥锁 */
    if(xSemaphoreTake(mbMutex, portMAX_DELAY) == pdTRUE)
    {
        /* 执行寄存器写入 */
        result = MB_WriteRegister(&mappingTable, address, value);
        
        /* 释放互斥锁 */
        xSemaphoreGive(mbMutex);
        
        return result;
    }
    
    return MB_ERROR_PROCESSING;
}
```

## 性能优化技巧

<details>
<summary>性能优化关键点</summary>

1. **避免频繁内存分配**：预分配缓冲区和资源，避免动态内存分配

```c
/* 使用静态分配而非动态分配 */
static uint8_t rxBuffer[256];
static uint8_t txBuffer[256];

/* 而不是 */
// uint8_t *rxBuffer = malloc(256);
// uint8_t *txBuffer = malloc(256);
```

2. **使用DMA加速数据传输**：减少CPU负担

```c
/* 使用DMA发送数据 */
void MBH_UartSendBufferDMA(uint8_t *buffer, uint16_t length)
{
    /* 配置DMA传输 */
    DMA_Config(DMA_CHANNEL_UART_TX, (uint32_t)buffer, (uint32_t)&USART1->DR, length);
    
    /* 启动DMA传输 */
    DMA_Start(DMA_CHANNEL_UART_TX);
}
```

3. **优化CRC计算**：使用查表法加速CRC计算

```c
/* CRC16查表法实现 */
static const uint16_t crc16Table[256] = {
    0x0000, 0xC0C1, 0xC181, 0x0140, /* 预先计算的CRC16表 */
    /* ... 此处省略其余值 ... */
};

uint16_t MB_CRC16_Table(uint8_t *buffer, uint16_t length)
{
    uint16_t crc = 0xFFFF;
    uint16_t i;
    uint8_t index;
    
    for(i = 0; i < length; i++)
    {
        index = (crc ^ buffer[i]) & 0xFF;
        crc = (crc >> 8) ^ crc16Table[index];
    }
    
    return crc;
}
```

4. **中断优先级合理设置**：确保关键中断能够及时处理

```c
/* 设置中断优先级 */
void MBH_ConfigInterruptPriority(void)
{
    /* 串口接收中断优先级高 */
    NVIC_SetPriority(USART1_IRQn, 0);
    
    /* 定时器中断优先级次之 */
    NVIC_SetPriority(TIM2_IRQn, 1);
    
    /* 其他中断优先级较低 */
    NVIC_SetPriority(SPI1_IRQn, 2);
}
```

</details>

## 调试与日志记录

在复杂系统中，完善的调试和日志功能有助于排查问题：

```c
/* 调试级别定义 */
typedef enum {
    MB_DEBUG_NONE = 0,
    MB_DEBUG_ERROR,
    MB_DEBUG_WARNING,
    MB_DEBUG_INFO,
    MB_DEBUG_DETAIL
} MBDebugLevel;

/* 当前调试级别 */
static MBDebugLevel mbDebugLevel = MB_DEBUG_INFO;

/* 调试日志函数 */
void MB_Debug(MBDebugLevel level, const char *format, ...)
{
    if(level <= mbDebugLevel)
    {
        va_list args;
        char buffer[256];
        
        va_start(args, format);
        vsnprintf(buffer, sizeof(buffer), format, args);
        va_end(args);
        
        /* 输出日志 */
        switch(level)
        {
            case MB_DEBUG_ERROR:
                printf("[Modbus ERROR] %s\r\n", buffer);
                break;
                
            case MB_DEBUG_WARNING:
                printf("[Modbus WARN] %s\r\n", buffer);
                break;
                
            case MB_DEBUG_INFO:
                printf("[Modbus INFO] %s\r\n", buffer);
                break;
                
            case MB_DEBUG_DETAIL:
                printf("[Modbus DETAIL] %s\r\n", buffer);
                break;
                
            default:
                break;
        }
    }
}

/* 帧数据调试输出 */
void MB_DebugFrame(const char *prefix, uint8_t *frame, uint16_t length)
{
    if(mbDebugLevel >= MB_DEBUG_DETAIL)
    {
        char buffer[512] = {0};
        char temp[8];
        int pos = 0;
        
        pos += snprintf(buffer + pos, sizeof(buffer) - pos, "%s: ", prefix);
        
        for(uint16_t i = 0; i < length && pos < sizeof(buffer) - 8; i++)
        {
            snprintf(temp, sizeof(temp), "%02X ", frame[i]);
            pos += snprintf(buffer + pos, sizeof(buffer) - pos, "%s", temp);
        }
        
        printf("%s\r\n", buffer);
    }
}
```

## 实际应用示例

将前面介绍的优化技术应用到实际项目中：

```c
/* main.c - 完整应用程序示例 */

#include "mb_core.h"
#include "mb_function.h"
#include "mb_mapping.h"
#include "mb_hal.h"

/* Modbus实例 */
static MBInstance mbInstance;

/* 寄存器映射表 */
static MBRegisterMappingTable mappingTable;

/* 寄存器值存储区 */
static uint16_t registerValues[32];

/* 设备配置 */
static MBPersistentConfig mbConfig;

/* 初始化Modbus应用 */
void ModbusApp_Init(void)
{
    /* 加载持久化配置 */
    MB_LoadConfig(&mbConfig);
    
    /* 初始化硬件抽象层 */
    MBH_Init();
    MBH_UartInit(
        BaudRateTable[mbConfig.baudRateCode],
        8,
        1,
        ParityModeTable[mbConfig.parityMode]
    );
    MBH_TimerInit(3650); /* 3.65ms @ 9600bps */
    
    /* 设置RS485为接收模式 */
    MBH_EnableReceive();
    
    /* 初始化寄存器值 */
    for(int i = 0; i < 32; i++)
    {
        registerValues[i] = 0;
    }
    
    /* 设置重要寄存器初始值 */
    registerValues[REG_DEV_ADDRESS] = mbConfig.deviceAddress;
    registerValues[REG_BAUD_RATE] = mbConfig.baudRateCode;
    registerValues[REG_PARITY_MODE] = mbConfig.parityMode;
    
    /* 定义寄存器映射 */
    static MBRegisterMapping registerMappings[] = {
        {0x0000, 1, MB_ACCESS_RO, &registerValues[0], ReadTemperatureRegister, NULL},
        {0x0001, 1, MB_ACCESS_RO, &registerValues[1], ReadHumidityRegister, NULL},
        {0x0066, 1, MB_ACCESS_RW, &registerValues[REG_DEV_ADDRESS], ReadDeviceAddressRegister, WriteDeviceAddressRegister},
        {0x0067, 1, MB_ACCESS_RW, &registerValues[REG_BAUD_RATE], ReadBaudRateRegister, WriteBaudRateRegister},
        {0x0068, 1, MB_ACCESS_RW, &registerValues[REG_PARITY_MODE], ReadParityModeRegister, WriteParityModeRegister}
    };
    
    /* 初始化寄存器映射表 */
    MB_InitRegisterMapping(&mappingTable, registerMappings, sizeof(registerMappings)/sizeof(registerMappings[0]));
    
    /* 初始化Modbus实例 */
    MB_Init(&mbInstance, mbConfig.deviceAddress);
    
    /* 注册功能码处理函数 */
    MB_RegisterFunctionHandler(0x03, MB_HandleReadHoldingRegisters);
    MB_RegisterFunctionHandler(0x06, MB_HandleWriteSingleRegister);
    MB_RegisterFunctionHandler(0x10, MB_HandleWriteMultipleRegisters);
    
    /* 设置调试级别 */
    #ifdef DEBUG_MODE
    mbDebugLevel = MB_DEBUG_DETAIL;
    #else
    mbDebugLevel = MB_DEBUG_ERROR;
    #endif
    
    MB_Debug(MB_DEBUG_INFO, "Modbus initialized with slave address: %d", mbConfig.deviceAddress);
}

/* 主循环 */
int main(void)
{
    /* 系统初始化 */
    SystemInit();
    
    /* 初始化Modbus应用 */
    ModbusApp_Init();
    
    /* 主循环 */
    uint32_t lastUpdateTime = 0;
    
    while(1)
    {
        /* 处理Modbus通信 */
        MB_Task();
        
        /* 定期更新传感器数据 */
        if(MBH_GetTime() - lastUpdateTime >= 500)
        {
            lastUpdateTime = MBH_GetTime();
            UpdateSensorData();
        }
        
        /* 处理其他应用任务 */
        ProcessApplicationTasks();
    }
}
```

## 单元测试

<details>
<summary>单元测试示例</summary>

为了确保代码质量，应编写单元测试：

```c
/* mb_core_test.c - Modbus核心功能测试 */

#include "unity.h"
#include "mb_core.h"
#include "mb_hal_mock.h"

MBInstance testInstance;

void setUp(void)
{
    /* 测试前初始化 */
    MB_Init(&testInstance, 1);
}

void tearDown(void)
{
    /* 测试后清理 */
}

/* 测试CRC计算 */
void test_MB_CRC16(void)
{
    uint8_t data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02};
    uint16_t crc = MB_CRC16(data, sizeof(data));
    
    TEST_ASSERT_EQUAL_HEX16(0x0B0C, crc);
}

/* 测试帧接收与处理 */
void test_MB_ProcessFrame(void)
{
    /* 构造一个有效的Modbus请求帧 */
    uint8_t frame[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x0B};
    
    /* 模拟接收数据 */
    for(int i = 0; i < sizeof(frame); i++)
    {
        MB_HandleRxData(&testInstance, frame[i]);
    }
    
    /* 模拟超时事件，触发帧处理 */
    MB_HandleTimeout(&testInstance);
    
    /* 验证处理结果 */
    TEST_ASSERT_EQUAL(MB_OK, MB_ProcessFrame(&testInstance));
    
    /* 验证响应帧 */
    TEST_ASSERT_GREATER_THAN(0, testInstance.txCount);
    TEST_ASSERT_EQUAL(0x01, testInstance.txBuffer[0]); /* 从机地址 */
    TEST_ASSERT_EQUAL(0x03, testInstance.txBuffer[1]); /* 功能码 */
}

/* 测试异常响应 */
void test_MB_SendException(void)
{
    /* 发送异常响应 */
    MB_SendException(&testInstance, 0x03, MB_EX_ILLEGAL_DATA_ADDRESS);
    
    /* 验证异常响应内容 */
    TEST_ASSERT_EQUAL(0x01, testInstance.txBuffer[0]); /* 从机地址 */
    TEST_ASSERT_EQUAL(0x83, testInstance.txBuffer[1]); /* 功能码+0x80 */
    TEST_ASSERT_EQUAL(0x02, testInstance.txBuffer[2]); /* 异常码 */
}

/* 运行所有测试 */
int main(void)
{
    UNITY_BEGIN();
    RUN_TEST(test_MB_CRC16);
    RUN_TEST(test_MB_ProcessFrame);
    RUN_TEST(test_MB_SendException);
    return UNITY_END();
}
```

</details>

## 总结

本章介绍了Modbus协议实现的优化与封装技术，包括：

1. **模块化设计**：将功能划分为不同层次，提高代码可维护性
2. **硬件抽象**：隔离硬件依赖，提高代码可移植性
3. **回调机制**：使用回调函数增强系统灵活性和扩展性
4. **错误处理**：完善的错误处理与日志记录机制
5. **参数持久化**：重要参数的持久化存储方案
6. **异步通信**：基于状态机的异步处理模型
7. **线程安全**：多线程环境下的安全访问机制
8. **性能优化**：减少内存分配、使用DMA、优化CRC计算等

通过这些优化技术，可以开发出高质量、高性能、易维护的Modbus通信应用，满足工业控制和物联网应用的需求。

---

**需要扩展的内容**：
1. 更多功能码的实现方法
2. 不同平台的移植指南
3. 与其他协议的集成（如Modbus TCP）
4. 高级调试技术与工具
5. 安全性考虑与实现 