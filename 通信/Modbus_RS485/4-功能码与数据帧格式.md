# 功能码与数据帧格式

本文详细介绍Modbus协议中最常用的三个功能码（03/06/16）及其数据帧格式，以及超时接收原理。

## 常用功能码概述

<div style="text-align: center; margin: 20px 0; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9; border-radius: 5px;">
在实际工业应用中，最常用的Modbus功能码是:<br>
<strong>03</strong>（读保持寄存器）<br>
<strong>06</strong>（写单个寄存器）<br>
<strong>16</strong>（写多个寄存器）
</div>

## 功能码03 - 读保持寄存器

功能码03用于读取一个或多个保持寄存器的内容。

<details>
<summary>功能码03应用场景</summary>

功能码03主要用于：
- 读取传感器数据（如温度、湿度、压力等）
- 读取设备状态信息
- 读取设备参数（如波特率、设备地址等）
- 读取计数值或累计值

例如，在温湿度传感器中，寄存器0通常存放温度值，寄存器1存放湿度值。
</details>

### 03功能码请求帧格式

| 字段 | 长度 | 数值/说明 |
|-----|------|----------|
| 从机地址 | 1字节 | 从机的地址（1-247） |
| 功能码 | 1字节 | 0x03 |
| 起始寄存器地址高字节 | 1字节 | 寄存器起始地址的高8位 |
| 起始寄存器地址低字节 | 1字节 | 寄存器起始地址的低8位 |
| 寄存器数量高字节 | 1字节 | 要读取的寄存器数量的高8位 |
| 寄存器数量低字节 | 1字节 | 要读取的寄存器数量的低8位 |
| CRC校验低字节 | 1字节 | CRC校验的低8位 |
| CRC校验高字节 | 1字节 | CRC校验的高8位 |

请求帧示例（十六进制）：

```
01 03 00 00 00 02 C4 0B
```

分析：
- `01`: 从机地址为1
- `03`: 功能码03（读保持寄存器）
- `00 00`: 起始寄存器地址为0
- `00 02`: 读取2个寄存器
- `C4 0B`: CRC校验值

### 03功能码响应帧格式

| 字段 | 长度 | 数值/说明 |
|-----|------|----------|
| 从机地址 | 1字节 | 从机的地址（与请求相同） |
| 功能码 | 1字节 | 0x03 |
| 字节数 | 1字节 | 返回数据的字节数（寄存器数量×2） |
| 数据1高字节 | 1字节 | 第1个寄存器值的高8位 |
| 数据1低字节 | 1字节 | 第1个寄存器值的低8位 |
| ... | ... | ... |
| 数据N高字节 | 1字节 | 第N个寄存器值的高8位 |
| 数据N低字节 | 1字节 | 第N个寄存器值的低8位 |
| CRC校验低字节 | 1字节 | CRC校验的低8位 |
| CRC校验高字节 | 1字节 | CRC校验的高8位 |

响应帧示例（十六进制）：

```
01 03 04 00 6F 00 25 3B 92
```

分析：
- `01`: 从机地址为1
- `03`: 功能码03
- `04`: 返回4个字节的数据（2个寄存器）
- `00 6F`: 第1个寄存器的值（111，可能是温度值）
- `00 25`: 第2个寄存器的值（37，可能是湿度值）
- `3B 92`: CRC校验值

## 功能码06 - 写单个寄存器

功能码06用于向单个保持寄存器写入指定的值。

### 06功能码请求帧格式

| 字段 | 长度 | 数值/说明 |
|-----|------|----------|
| 从机地址 | 1字节 | 从机的地址（1-247） |
| 功能码 | 1字节 | 0x06 |
| 寄存器地址高字节 | 1字节 | 寄存器地址的高8位 |
| 寄存器地址低字节 | 1字节 | 寄存器地址的低8位 |
| 寄存器值高字节 | 1字节 | 写入值的高8位 |
| 寄存器值低字节 | 1字节 | 写入值的低8位 |
| CRC校验低字节 | 1字节 | CRC校验的低8位 |
| CRC校验高字节 | 1字节 | CRC校验的高8位 |

请求帧示例（十六进制）：

```
01 06 00 66 00 03 A8 14
```

分析：
- `01`: 从机地址为1
- `06`: 功能码06（写单个寄存器）
- `00 66`: 寄存器地址0x0066（可能是设备地址寄存器）
- `00 03`: 写入值为3（设置新设备地址为3）
- `A8 14`: CRC校验值

### 06功能码响应帧格式

正常情况下，06功能码的响应帧与请求帧完全相同，表示写入操作成功。

响应帧示例（十六进制）：

```
01 06 00 66 00 03 A8 14
```

<div style="background-color: #fff3cd; padding: 10px; margin: 15px 0; border-left: 4px solid #ffc107; border-radius: 3px;">
<strong>提示：</strong> 功能码06的响应是请求的回显，表示操作已执行。这种设计可以确认从机已正确接收并执行请求，无需额外确认。
</div>

## 功能码16 - 写多个寄存器

功能码16用于向多个连续的保持寄存器写入值。当需要同时修改多个参数时，此功能码比连续使用06功能码更高效。

### 16功能码请求帧格式

| 字段 | 长度 | 数值/说明 |
|-----|------|----------|
| 从机地址 | 1字节 | 从机的地址（1-247） |
| 功能码 | 1字节 | 0x10（十六进制的16） |
| 起始寄存器地址高字节 | 1字节 | 起始寄存器地址的高8位 |
| 起始寄存器地址低字节 | 1字节 | 起始寄存器地址的低8位 |
| 寄存器数量高字节 | 1字节 | 寄存器数量的高8位 |
| 寄存器数量低字节 | 1字节 | 寄存器数量的低8位 |
| 字节数 | 1字节 | 数据区的字节数（寄存器数量×2） |
| 数据1高字节 | 1字节 | 第1个寄存器值的高8位 |
| 数据1低字节 | 1字节 | 第1个寄存器值的低8位 |
| ... | ... | ... |
| 数据N高字节 | 1字节 | 第N个寄存器值的高8位 |
| 数据N低字节 | 1字节 | 第N个寄存器值的低8位 |
| CRC校验低字节 | 1字节 | CRC校验的低8位 |
| CRC校验高字节 | 1字节 | CRC校验的高8位 |

请求帧示例（十六进制）：

```
01 10 00 00 00 04 08 00 0A 00 14 00 1E 00 28 CF E7
```

分析：
- `01`: 从机地址为1
- `10`: 功能码16（写多个寄存器）
- `00 00`: 起始寄存器地址为0
- `00 04`: 写入4个寄存器
- `08`: 数据区包含8个字节（4个寄存器×2）
- `00 0A 00 14 00 1E 00 28`: 写入的4个寄存器值（10, 20, 30, 40）
- `CF E7`: CRC校验值

### 16功能码响应帧格式

| 字段 | 长度 | 数值/说明 |
|-----|------|----------|
| 从机地址 | 1字节 | 从机的地址（与请求相同） |
| 功能码 | 1字节 | 0x10 |
| 起始寄存器地址高字节 | 1字节 | 起始寄存器地址的高8位 |
| 起始寄存器地址低字节 | 1字节 | 起始寄存器地址的低8位 |
| 寄存器数量高字节 | 1字节 | 寄存器数量的高8位 |
| 寄存器数量低字节 | 1字节 | 寄存器数量的低8位 |
| CRC校验低字节 | 1字节 | CRC校验的低8位 |
| CRC校验高字节 | 1字节 | CRC校验的高8位 |

响应帧示例（十六进制）：

```
01 10 00 00 00 04 41 18
```

分析：
- `01`: 从机地址为1
- `10`: 功能码16
- `00 00`: 起始寄存器地址为0
- `00 04`: 成功写入4个寄存器
- `41 18`: CRC校验值

## 三种功能码的对比

<table border="1" style="width:100%; border-collapse: collapse; margin: 15px 0;">
  <tr style="background-color: #f2f2f2;">
    <th>特性</th>
    <th>功能码03（读寄存器）</th>
    <th>功能码06（写单寄存器）</th>
    <th>功能码16（写多寄存器）</th>
  </tr>
  <tr>
    <td>操作类型</td>
    <td>读取</td>
    <td>写入</td>
    <td>写入</td>
  </tr>
  <tr>
    <td>寄存器数量</td>
    <td>可读取多个</td>
    <td>只能写入单个</td>
    <td>可写入多个</td>
  </tr>
  <tr>
    <td>请求帧长度</td>
    <td>8字节（固定）</td>
    <td>8字节（固定）</td>
    <td>9+2×N字节（N为寄存器数量）</td>
  </tr>
  <tr>
    <td>响应帧长度</td>
    <td>5+2×N字节</td>
    <td>8字节（与请求帧相同）</td>
    <td>8字节（固定）</td>
  </tr>
  <tr>
    <td>典型应用</td>
    <td>读取传感器数据、状态信息</td>
    <td>修改单个设置参数</td>
    <td>批量修改多个参数</td>
  </tr>
</table>

## 超时接收原理

<details>
<summary>为什么需要超时接收？</summary>

Modbus RTU使用时间间隔来区分不同的数据帧，而不是使用特定的起始符和结束符。超时接收机制是实现这种断帧方式的关键技术。

在单片机编程中，需要正确处理数据接收和断帧，以确保正确解析Modbus数据包。
</details>

### 超时接收时间设置

超时时间的设置基于Modbus协议规定的字符间时间和帧间时间：

- **字符间最大间隔**：1.5个字符时间
- **帧间最小间隔**：3.5个字符时间

在实际应用中，通常以3.5个字符时间作为超时时间的基准，并稍有调整以提高稳定性。

例如，9600波特率下的计算：
- 10位/字符（包括起始位和停止位）
- 9600位/秒传输速率
- 1个字符传输时间 = 10 ÷ 9600 ≈ 1.04ms
- 3.5个字符时间 ≈ 3.65ms

实际编程中可以设置为4-10ms的超时时间。

### 超时接收的程序实现

<details>
<summary>超时接收算法</summary>

以下是超时接收的基本算法：

1. 初始化一个定时器
2. 每当接收到一个字节：
   - 将字节保存到缓冲区
   - 重置定时器计数
3. 定时器中断服务程序：
   - 增加计数值
   - 当计数值超过设定的超时阈值时，置位接收完成标志
4. 主程序处理：
   - 检测接收完成标志
   - 若置位，则解析接收到的数据包
   - 解析完成后清除标志位

这种方法确保在没有新数据到来且超过设定时间后，认为一个数据包接收完成。
</details>

```c
// 超时接收实现示例（伪代码）
volatile uint8_t recv_buf[256];       // 接收缓冲区
volatile uint8_t recv_index = 0;      // 接收索引
volatile uint8_t frame_complete = 0;  // 接收完成标志
volatile uint16_t timeout_cnt = 0;    // 超时计数器

// UART接收中断
void UART_RX_IRQHandler(void) {
    recv_buf[recv_index++] = UART_ReadByte();  // 读取数据
    timeout_cnt = 0;                           // 清零超时计数器
}

// 1ms定时器中断
void TIMER_IRQHandler(void) {
    timeout_cnt++;
    
    // 超时判断（例如5ms）
    if(timeout_cnt > 5 && recv_index > 0) {
        frame_complete = 1;  // 置位帧接收完成标志
    }
}

// 主程序
void main(void) {
    // 初始化...
    
    while(1) {
        if(frame_complete) {
            // 处理接收到的Modbus帧
            ProcessModbusFrame(recv_buf, recv_index);
            
            // 清除标志和索引，准备接收下一帧
            recv_index = 0;
            frame_complete = 0;
        }
        
        // 其他处理...
    }
}
```

## 寄存器地址与变量映射

在实际开发中，Modbus寄存器地址并不对应实际的物理地址，而是一种约定的方式，用于访问设备内的变量。

### 寄存器地址映射示例

<div style="margin: 15px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
例如，在一个温湿度传感器中：<br><br>

<strong>寄存器0（地址0x0000）</strong>：温度值<br>
<strong>寄存器1（地址0x0001）</strong>：湿度值<br>
<strong>寄存器2（地址0x0002）</strong>：压力值<br>
<strong>寄存器3（地址0x0003）</strong>：流量值<br>
<strong>寄存器102（地址0x0066）</strong>：设备地址<br>
<strong>寄存器103（地址0x0067）</strong>：波特率设置<br>
</div>

当程序收到Modbus命令请求读取寄存器0和1时，实际上是要求从设备返回温度和湿度的值。

### 实现方式

在单片机程序中，通常通过以下方式实现寄存器地址与变量的映射：

1. **数组映射**：创建一个数组作为寄存器表，直接通过索引访问
   ```c
   uint16_t modbus_registers[256];  // 寄存器表
   // 更新寄存器值
   modbus_registers[0] = temperature;
   modbus_registers[1] = humidity;
   ```

2. **函数映射**：使用函数根据地址获取或设置相应的变量
   ```c
   uint16_t GetRegisterValue(uint16_t addr) {
       switch(addr) {
           case 0: return temperature;
           case 1: return humidity;
           // ...
       }
       return 0;
   }
   ```

3. **结构体映射**：使用结构体组织相关寄存器
   ```c
   typedef struct {
       uint16_t temperature;  // 寄存器0
       uint16_t humidity;     // 寄存器1
       uint16_t pressure;     // 寄存器2
       uint16_t flow;         // 寄存器3
       // ...
   } DeviceRegisters;
   ```

---

**需要插入图片的位置**：
1. 03功能码请求/响应帧格式图
2. 06功能码请求/响应帧格式图
3. 16功能码请求/响应帧格式图
4. 超时接收时序图

---

## 总结

- 功能码03（读保持寄存器）用于读取设备中的数据
- 功能码06（写单个寄存器）用于修改单个参数
- 功能码16（写多个寄存器）用于批量修改多个参数
- 超时接收是Modbus RTU通信中断帧的关键技术
- 寄存器地址是访问设备变量的约定方式，不对应实际物理地址 